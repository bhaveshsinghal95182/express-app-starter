import inquirer from "inquirer";
import fs from "fs-extra";
import path from "path";
import { exec as execCallback } from "child_process";
import { promisify } from "util";
import ora from "ora";
import { fileURLToPath } from "url";

const exec = promisify(execCallback);

export class Scaffolder {
  constructor() {
    this.projectName = "";
    this.options = {
      src: false,
      structuredSrc: false,
      docker: false,
      language: "ts",
    };
    const __dirname = path.dirname(fileURLToPath(import.meta.url));
    this.templatePath = path.resolve(__dirname, "../templates");
  }

  getGitignoreContent() {
    return `# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.*
!.env.example

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Sveltekit cache directory
.svelte-kit/

# vitepress build output
**/.vitepress/dist

# vitepress cache directory
**/.vitepress/cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# Firebase cache directory
.firebase/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v3
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions

# Vite logs files
vite.config.js.timestamp-*
vite.config.ts.timestamp-*`;
  }

  async run() {
    await this.promptUser();
    const projectPath = path.join(process.cwd(), this.projectName);

    await this.generateProject();

    console.log("‚öôÔ∏è  Initializing Git and installing dependencies...");
    await this.runCommands(projectPath);

    console.log(`\n‚úÖ Project ${this.projectName} scaffolded successfully!`);
    console.log(`\nNavigate to your project and start developing:\n`);
    console.log(`  cd ${this.projectName}`);
    console.log(`  pnpm dev\n`);
  }

  async runCommands(projectPath) {
    const opts = { cwd: projectPath };
    const spinner = ora();

    try {
      await exec("git init", opts);
      console.log("‚úì Git repository initialized.");

      spinner.start("Installing dependencies with pnpm...");
      await exec("pnpm install", opts);
      spinner.succeed("Dependencies installed with pnpm.");
    } catch (error) {
      if (spinner.isSpinning) {
        spinner.fail("Failed to install dependencies.");
      }
      console.error("\n‚ùå Error during setup:", error.stderr || error.message);
    }
  }

  async promptUser() {
    const answers = await inquirer.prompt([
      {
        name: "projectName",
        message: "Project name?",
        default: "my-express-app",
      },
      {
        name: "language",
        type: "list",
        message: "Which language do you want to use?",
        choices: ["ts", "js"],
        default: "ts",
      },
      { name: "docker", type: "confirm", message: "Include Dockerfile?" },
    ]);

    this.projectName = answers.projectName;
    this.options.docker = answers.docker;
    this.options.language = answers.language;

    // This logic can also be simplified to always ask
    const { src } = await inquirer.prompt([
      {
        name: "src",
        type: "confirm",
        message: "Do you want a src folder?",
        default: true,
      },
    ]);
    this.options.src = src;

    if (this.options.src) {
      const { structured } = await inquirer.prompt([
        {
          name: "structured",
          type: "confirm",
          message: "Use structured src/ (routes, controllers, services)?",
        },
      ]);
      this.options.structuredSrc = structured;
    }
  }

  async generateProject() {
    const dest = path.join(process.cwd(), this.projectName);

    if (this.options.language) {
      const languageFolder = this.options.language;
      await fs.copy(
        path.join(this.templatePath, "base", languageFolder),
        dest,
        { globOptions: { dot: true } }
      );
    }

    const envContent = "PORT=3000";
    const envPath = path.join(dest, ".env");
    await fs.writeFile(envPath, envContent);

    if (this.options.src) {
      const destSrcPath = path.join(dest, "src");

      if (this.options.structuredSrc) {
        // CASE: Structured src
        const sourceDir = path.join(
          this.templatePath,
          "modules",
          "src-structured",
          this.options.language
        );
        await fs.copy(sourceDir, destSrcPath);
      } else {
        // CASE: Simple src
        await fs.ensureDir(destSrcPath);
        const sourceFile = path.join(
          this.templatePath,
          "modules",
          "src",
          `index.${this.options.language}`
        );
        const destFile = path.join(
          destSrcPath,
          `index.${this.options.language}`
        );
        await fs.copy(sourceFile, destFile);
      }
    } else {
      // CASE: No src folder
      await fs.copy(path.join(this.templatePath, "modules", "no-src"), dest);
    }

    if (this.options.docker) {
      const language = this.options.language;

      // Copy Dockerfile
      const dockerfileSource = path.join(
        this.templatePath,
        "modules",
        "docker",
        language
      );
      await fs.copy(dockerfileSource, dest);
    }

    // Ensure .gitignore exists (runtime creation as backup)
    const gitignorePath = path.join(dest, ".gitignore");
    const gitignoreExists = await fs.pathExists(gitignorePath);
    if (!gitignoreExists) {
      console.log("üìù Creating .gitignore file...");
      await fs.writeFile(gitignorePath, this.getGitignoreContent());
    }

    // Update package.json name
    const pkgPath = path.join(dest, "package.json");
    const pkg = await fs.readJson(pkgPath);
    pkg.name = this.projectName;
    
    // Update scripts based on src folder choice
    if (this.options.src) {
      if (this.options.language === "js") {
        pkg.scripts.dev = "nodemon src/index.js";
        pkg.scripts.start = "node src/index.js";
      } else if (this.options.language === "ts") {
        pkg.scripts.dev = "tsx watch src/index.ts";
        // build and start scripts remain the same for TS with src folder
        // as tsconfig.json is already configured for src folder
      }
    } else {
      // No src folder - update TypeScript tsconfig.json if needed
      if (this.options.language === "ts") {
        const tsconfigPath = path.join(dest, "tsconfig.json");
        const tsconfig = await fs.readJson(tsconfigPath);
        
        // Update tsconfig for root-level TypeScript files
        tsconfig.compilerOptions.rootDir = "./";
        tsconfig.include = ["*.ts"];
        
        await fs.writeJson(tsconfigPath, tsconfig, { spaces: 2 });
      }
    }
    
    await fs.writeJson(pkgPath, pkg, { spaces: 2 });
  }
}
